<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/05/03/Hello-World/</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>我是一个coder，但很多时候又不像coder；我着迷这个世界的多样性，但有时候也被多样的世界搞得晕头转向。</p>
<p>初次相见，一如往常：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Hello,world!"</span>;</span><br></pre></td></tr></table></figure>

<h1 id="子路说"><a href="#子路说" class="headerlink" title="子路说"></a>子路说</h1><p>新开博客实在也没想到好名字，“简约但不简单”是我喜欢的风格，媳妇突发奇想：<strong>“子路说”</strong>。嗯…简单且带有淡淡的诗意，好名字。</p>
<h1 id="左手代码右手诗"><a href="#左手代码右手诗" class="headerlink" title="左手代码右手诗"></a>左手代码右手诗</h1><p>左手代码右手诗，很高兴认识你<strong>:)</strong></p>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>Wireshark实战Keep-Alive</title>
    <url>/2020/05/10/keep-alive/</url>
    <content><![CDATA[<p>HTTP在我们的生产实践中至关重要，HTTP协议就像水与空气一般，太常见了但又无时无刻不存在。<br>后面打算写一系列HTTP总结的文章，以期能够真正理解掌握HTTP，今天我们就以Keep-Alive开始吧！</p>
<h2 id="一、What-Keep-Alive"><a href="#一、What-Keep-Alive" class="headerlink" title="一、What Keep-Alive"></a>一、What Keep-Alive</h2><p>Keep-Alive见名知意：即 <strong>保持存在，</strong>在网络中也就是“<strong>保持连接”</strong>的意思。</p>
<p>在http性能优化中keep-alive至关重要，今天我们就来深入了解实战下吧！</p>
<h2 id="二、Why-Keep-Alive"><a href="#二、Why-Keep-Alive" class="headerlink" title="二、Why Keep-Alive"></a>二、Why Keep-Alive</h2><p>我们都知道，Http属于应用层协议，其是建立在TCP/IP网络模型上进行数据传输。</p>
<p>短连接与长连接的区别如图：</p>
<p><img src="http://static.zybuluo.com/ericliu001/bq7a5bxfcmg1preqhch87zcg/image.png" alt="image.png-428.6kB"></p>
<p>如果是短连接的话，每次 <strong>请求前</strong> 都要TCP建立连接、每次 <strong>响应后</strong> 都要TCP断开连接。</p>
<p>如果是长连接的话，纵使N次 <strong>请求-响应</strong>，只需在第一次发送 <strong>请求前</strong> 建立TCP连接，最后一次 <strong>响应后</strong> 断开连接。</p>
<hr>
<p>我们知道TCP三次握手、四次挥手是比较昂贵的时间资源，短连接场景下每次HTTP连接都要经历这个过程，那么，这个连接为什么不能复用呢？</p>
<p> 长连接在HTTP 1.1应运而生，即Keep-Alive。</p>
<h2 id="三、How-Keep-Alive"><a href="#三、How-Keep-Alive" class="headerlink" title="三、How Keep-Alive"></a>三、How Keep-Alive</h2><p>Keep-Alive功能需要Client与Server同时支持才可以，下面我们使用3个工具演示Keep-Alive的过程</p>
<ol>
<li>WireShark</li>
<li>Nginx</li>
<li>Curl</li>
</ol>
<p>Nginx安装我们就不细说了，来看一下Nginx的配置吧：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    <span class="comment"># 空闲连接的超时时间</span></span><br><span class="line">    keepalive_timeout  <span class="number">60</span>s;</span><br><span class="line">    <span class="comment"># 长连接上可发送的最大请求数，为了实验我们设置为3</span></span><br><span class="line">    keepalive_requests <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        listen <span class="number">80</span>;</span><br><span class="line">        location / &#123;</span><br><span class="line">            default_type text/html;</span><br><span class="line">            content_by_lua_block &#123;</span><br><span class="line">                ngx.say(<span class="string">"&lt;p&gt;hello, world&lt;/p&gt;"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置中有两个参数至关重要:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">keepalive_timeout,设置长连接的超时时间，如果一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源</span><br><span class="line">keepalive_requests，指长连接上发送的最大请求数</span><br></pre></td></tr></table></figure>

<hr>
<p>到这里默认你的Nginx，也就是Server已经根据上述配置启动成功了，我们接下来编写一段Client请求测试代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> $ch = curl_init();</span><br><span class="line"> curl_setopt($ch, CURLOPT_URL, <span class="string">"http://localhost"</span>);</span><br><span class="line"> curl_setopt($ch, CURLOPT_HEADER, <span class="keyword">false</span>);</span><br><span class="line"> curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"> <span class="comment">//第1次请求</span></span><br><span class="line"> curl_exec($ch);</span><br><span class="line"> <span class="comment">//第2次请求</span></span><br><span class="line"> curl_exec($ch);</span><br><span class="line"> <span class="comment">//第3次请求</span></span><br><span class="line"> curl_exec($ch);</span><br><span class="line"> <span class="comment">//第4次请求</span></span><br><span class="line"> curl_exec($ch);</span><br><span class="line"> <span class="comment">//关闭连接</span></span><br><span class="line"> curl_close($ch);</span><br></pre></td></tr></table></figure>

<p>为什么要编写这段代码呢，直接命令行多次执行curl命令不行吗？</p>
<p>答案是不行的，为什么呢？因为我试过，哈哈。命令行执行curl时无法保持长连接的。</p>
<hr>
<p>好了，Server、Client我们完成，接下来我们打开wireshark等待鱼上钩。</p>
<p>我们执行Client测试代码，WireShark抓包如下</p>
<p><img src="http://static.zybuluo.com/ericliu001/scxmgn17apu4x4jfkk56saxr/image.png" alt="image.png-338.4kB"></p>
<p>我们看到，3次请求之后，TCP就断开了连接，第4次请求重新建立连接，为什么呢？</p>
<p>还记得我们配置<code>keepalive_requests 3</code>这个参数吗？对，在发送请求3次后断开连接，就是这个意思。</p>
<p>如此，我们看到，Keep-Alive确实起作用了，这样网络传输性能就提高了很多。</p>
<p>Enjoy！：）</p>
]]></content>
      <categories>
        <category>HTTP Learning</category>
      </categories>
  </entry>
  <entry>
    <title>一. Golang中的类型</title>
    <url>/2020/05/31/golang_types/</url>
    <content><![CDATA[<h2 id="一-变量"><a href="#一-变量" class="headerlink" title="一. 变量"></a>一. 变量</h2><h3 id="1-变量定义"><a href="#1-变量定义" class="headerlink" title="1.变量定义"></a>1.变量定义</h3><p>关键字<code>var</code>定义变量，且类型放在变量名后面，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p>先想到变量名再想到变量类型，这样更加符合我们的思维模式。<br>变量在声明时会被初始化为zero value，避免出现不可预测的行为。</p>
<h3 id="2-类型推断"><a href="#2-类型推断" class="headerlink" title="2.类型推断"></a>2.类型推断</h3><p>如果在声明变量时显示的赋值，可以省略变量类型，由编译器进行推断。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"eric"</span></span><br></pre></td></tr></table></figure>
<h3 id="3-简短模式"><a href="#3-简短模式" class="headerlink" title="3.简短模式"></a>3.简短模式</h3><p>更加简洁的方式定义变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name := <span class="string">"eric"</span></span><br></pre></td></tr></table></figure>
<p>简短模式很方便，但也有一些限制：</p>
<ul>
<li>只能函数内部使用</li>
<li>必须显示初始化</li>
<li>不能提供数据类型</li>
</ul>
<p>简短模式也可能带来一些风险，需要注意：比如原本打算修改全局变量，但不小心用简短模式将全局变量进行了重新定义并覆盖。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestVariable</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">	t.Log(&amp;x,x) <span class="comment">//0x1225290 100</span></span><br><span class="line">	x := <span class="string">"david"</span></span><br><span class="line">	t.Log(&amp;x,x) <span class="comment">//0xc00008e4f0 david</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简短模式有时候也会退化为赋值操作，比如这样写是错的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestVariable</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">	name := <span class="string">"eric"</span></span><br><span class="line">	name := <span class="string">"david"</span> <span class="comment">//抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这样写是对的(退化为赋值操作)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestVariable</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">	name := <span class="string">"eric"</span></span><br><span class="line">	name, age := <span class="string">"david"</span>, <span class="number">28</span> <span class="comment">//此时退化成了赋值操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种退化有时候很有用，比如允许我们重复使用err变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestVariable</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">	f, err := os.open(<span class="string">"/tmp/tmp.log"</span>)</span><br><span class="line">	...</span><br><span class="line">	n,err := f.Read(buf) <span class="comment">//err退化为赋值操作，n新定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-一次定义多个变量"><a href="#4-一次定义多个变量" class="headerlink" title="4.一次定义多个变量"></a>4.一次定义多个变量</h3><p>为了“偷懒”，我们可以一次定义多个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x, name = <span class="number">3</span>, <span class="string">"eric"</span></span><br><span class="line">x, name := <span class="number">3</span>, <span class="string">"eric"</span></span><br></pre></td></tr></table></figure>

<p>同时建议我们以组的方式整理多行变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">10</span></span><br><span class="line">x, name := <span class="number">3</span>, <span class="string">"eric"</span></span><br></pre></td></tr></table></figure>

<h3 id="5-多变量赋值"><a href="#5-多变量赋值" class="headerlink" title="5.多变量赋值"></a>5.多变量赋值</h3><p>在没有多变量赋值前，我们交换x,y的值总需要借助tmp变量来完成，现在不用了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func TestVariable(t *testing.T)  &#123;</span><br><span class="line">	x, y :&#x3D; 10, 20</span><br><span class="line">	x ,y &#x3D; y, x &#x2F;&#x2F; 交换后 x &#x3D; 20，y&#x3D;10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>机制就是做多变量赋值时，会先计算出所有右值，然后依次完成左值得赋值操作。<br>下面也是一样道理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">	x, y :&#x3D; 1, 2</span><br><span class="line">	x, y &#x3D; y+2 ,x+5 &#x2F;&#x2F;先计算y+2，x+5的值再赋给左边，所以完成后是x&#x3D;4,y&#x3D;6</span><br><span class="line">	println(x,y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-空占位符"><a href="#6-空占位符" class="headerlink" title="6.空占位符"></a>6.空占位符</h3><p>未使用的局部变量会造成编译不通过，这有助于养成良好的编程习惯。</p>
<p>但有时候我们也需要规避编译器对未使用变量的检查，这就用到了“_”占位符.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x, _ :&#x3D; strconv.Atoi(&quot;12&quot;) &#x2F;&#x2F;忽略Atoi的err返回值</span><br></pre></td></tr></table></figure>

<h2 id="二-常量"><a href="#二-常量" class="headerlink" title="二. 常量"></a>二. 常量</h2><h3 id="1-常量定义"><a href="#1-常量定义" class="headerlink" title="1.常量定义"></a>1.常量定义</h3><p>常量表示运行期恒定不可变的值，通常是字面量，目的是消除magic number。</p>
<p>常量值必须是：</p>
<ul>
<li>字符</li>
<li>字符串</li>
<li>数字</li>
<li>bool</li>
</ul>
<p>常量可以显示的声明类型，当然也支持类型推断。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testConst</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">const</span> name <span class="keyword">string</span> =<span class="string">"eric"</span></span><br><span class="line">    <span class="keyword">const</span> name2 = <span class="string">"eric"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种写法都是对的。</p>
<h3 id="2-常量组"><a href="#2-常量组" class="headerlink" title="2.常量组"></a>2.常量组</h3><p>我们可以定义一系列常量，放到常量组中，这样省事也好看一些。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testConst</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		name =<span class="string">"eric"</span></span><br><span class="line">		age = <span class="number">28</span></span><br><span class="line">		sex = <span class="string">"male"</span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果常量组中元素不指定类型、初始化值，则与上一行非空常量右值相同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testConst</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		x = <span class="number">120</span>		<span class="comment">//120</span></span><br><span class="line">		y			<span class="comment">//120</span></span><br><span class="line">		s = <span class="string">"abc"</span>	<span class="comment">//abc</span></span><br><span class="line">		z			<span class="comment">//abc</span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-枚举"><a href="#3-枚举" class="headerlink" title="3.枚举"></a>3.枚举</h3><p>Go中没有enum的定义，但可以借助iota标识符来实现。</p>
<p>iota 在常量中第1行出现时是0，第2行出现时是1，看起来好像就是const中所在元素的第几行，然后减1的一个值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testEnum</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		x = <span class="literal">iota</span>	<span class="comment">//0</span></span><br><span class="line">		s			<span class="comment">//1</span></span><br><span class="line">		z			<span class="comment">//2</span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testEnum</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		x = <span class="number">100</span>		<span class="comment">//100</span></span><br><span class="line">		s = <span class="literal">iota</span>	<span class="comment">//1</span></span><br><span class="line">		z = <span class="number">33</span>		<span class="comment">//33</span></span><br><span class="line">		m = <span class="literal">iota</span>	<span class="comment">//3</span></span><br><span class="line">		n 			<span class="comment">//4</span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>best practice:在实际应用中，建议用自定义类型实现用途明确的枚举</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义weekend类型</span></span><br><span class="line"><span class="keyword">type</span> weekend <span class="keyword">byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testEnum</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		sun weekend = <span class="literal">iota</span></span><br><span class="line">		mon</span><br><span class="line">		tue</span><br><span class="line">		wed</span><br><span class="line">		thur</span><br><span class="line">		fri</span><br><span class="line">		sat</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-类型"><a href="#三-类型" class="headerlink" title="三. 类型"></a>三. 类型</h2><p>通过一张图看go类型<br><img src="http://static.zybuluo.com/ericliu001/lxo7vbcr0gd271vzgk6o9r22/go%E7%B1%BB%E5%9E%8B.png" alt="go类型.png-327.9kB"></p>
<h3 id="1-类型转换"><a href="#1-类型转换" class="headerlink" title="1.类型转换"></a>1.类型转换</h3><p>GO不支持隐式类型转换，必须显示转换才可以。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">int</span> = <span class="number">8</span></span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">float64</span> = <span class="keyword">float64</span>(m)</span><br></pre></td></tr></table></figure>
<h3 id="2-别名"><a href="#2-别名" class="headerlink" title="2.别名"></a>2.别名</h3><p>通过上面的图我们看到</p>
<ul>
<li>byte是uint8的别名</li>
<li>rune是int32的别名</li>
</ul>
<p>别名不需要类型转换，可以直接赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testAlias</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">//byte alias uint8</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">byte</span> = <span class="number">8</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">uint8</span> = a</span><br><span class="line"></span><br><span class="line">	<span class="comment">//rune alias int32</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">rune</span> = <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> d <span class="keyword">int32</span> = c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-引用类型"><a href="#3-引用类型" class="headerlink" title="3.引用类型"></a>3.引用类型</h3><p>引用类型包括slice、map、channel三种类型，相比数字、数组等类型，引用类型除分配内存外，还会初始化一系列属性，如指针、长度、容量等。</p>
<h3 id="4-自定义类型"><a href="#4-自定义类型" class="headerlink" title="4.自定义类型"></a>4.自定义类型</h3><p>color为自定义类型，但不是byte的别名，color与byte是两种完全不同的类型。<br>除操作符外，自定义类型不会集成基础类型的任何信息(包括方法)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> color <span class="keyword">byte</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Golang 学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>二. Golang中的表达式</title>
    <url>/2020/05/31/golang_expression/</url>
    <content><![CDATA[<h2 id="一-运算符"><a href="#一-运算符" class="headerlink" title="一. 运算符"></a>一. 运算符</h2><p>Go语言的运算符和大多数语言一样，我们只看比较特殊的。</p>
<h3 id="1-自增-自减"><a href="#1-自增-自减" class="headerlink" title="1.自增/自减"></a>1.自增/自减</h3><p>自增/自减 只能作为独立语句，不能用于表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">    <span class="comment">//语法错误</span></span><br><span class="line">	<span class="keyword">if</span> (a++) &gt; <span class="number">1</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时自增/自减，只能是后置操作，不能前置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	<span class="comment">//正确</span></span><br><span class="line">	a++</span><br><span class="line">	<span class="comment">//错误</span></span><br><span class="line">	++a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-指针"><a href="#2-指针" class="headerlink" title="2.指针"></a>2.指针</h3><p>内存地址与指针是两回事，不能混为一谈。内存地址是内存中每个字节单元的唯一编号，而指针是一个实体。‘指针会分配内存空间专门来保存对象的内存地址。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &amp; 取址运算符</span></span><br><span class="line"><span class="comment">// * 间接使用指针指向的内存地址的对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	x:=<span class="number">10</span></span><br><span class="line">	<span class="comment">//p保存x的内存地址</span></span><br><span class="line">	<span class="keyword">var</span> p *<span class="keyword">int</span>=&amp;x</span><br><span class="line">	<span class="comment">//*p实际上就是x</span></span><br><span class="line">	*p+=<span class="number">20</span></span><br><span class="line">	<span class="comment">//30 0xc00002e770</span></span><br><span class="line">	<span class="built_in">println</span>(*p,p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针类型只支持相等运算符，不支持加减乘除等运算。<br>如果两个指针指向相同的空间，或都为nil，则相等，否则不等。</p>
<p>指针没有指向“<strong>成员</strong>”的”-&gt;”运算符，统一使用”.”</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	a:= <span class="keyword">struct</span> &#123;</span><br><span class="line">		x <span class="keyword">int</span></span><br><span class="line">	&#125;&#123;&#125;</span><br><span class="line">	a.x=<span class="number">100</span></span><br><span class="line">	p:=&amp;a</span><br><span class="line">	<span class="comment">//相当于p-&gt;x+=100</span></span><br><span class="line">	p.x+=<span class="number">100</span></span><br><span class="line">	<span class="built_in">println</span>(p.x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-流程控制"><a href="#二-流程控制" class="headerlink" title="二. 流程控制"></a>二. 流程控制</h2><h3 id="1-if…else-if…else…"><a href="#1-if…else-if…else…" class="headerlink" title="1.if…else if…else…"></a>1.if…else if…else…</h3><ul>
<li>对初始化语句支持，但初始化语句中定义的变量，使用范围仅限于该语句块内</li>
<li>条件表达式必须是bool类型，可省略括号</li>
<li>左花括号不能另起一行</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">if</span> x:=<span class="number">3</span>;x&gt;<span class="number">5</span>&#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"a"</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> x&lt;<span class="number">12</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"b"</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"c"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-switch"><a href="#2-switch" class="headerlink" title="2.switch"></a>2.switch</h3><ul>
<li>同if…else，switch也支持表达式赋值</li>
<li>同if…else，switch左花括号也不能另起一行</li>
<li>case a,b 代表 case a || case b</li>
<li>每个case默认break，如果不想break，需执行fallthrough，但不再匹配后续条件表达式</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面代码输出 a|b y</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	x,y,a,b:=<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">switch</span> x &#123;</span><br><span class="line">	<span class="keyword">case</span> a,b:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"a|b"</span>)</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> y:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"y"</span>)</span><br><span class="line">	<span class="keyword">case</span> x:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"x"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"unknown"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>case a,b</code>使用了<code>fallthrough</code>，所以不匹配下一个表达式 <code>case y</code> 了，会直接执行<code>case y</code>的代码。</p>
<p>有时候switch也会被当做if…else来用，此时不用写表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	x:=<span class="number">12</span></span><br><span class="line">	<span class="keyword">switch</span>  &#123;</span><br><span class="line">	<span class="keyword">case</span> x&lt;<span class="number">10</span>:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"x"</span>)</span><br><span class="line">	<span class="keyword">case</span> x&gt;<span class="number">10</span> &amp;&amp; x&lt;<span class="number">15</span>:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"bigger x"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"unknown"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-for"><a href="#3-for" class="headerlink" title="3.for"></a>3.for</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">//正常for语句</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//相当于while(x&lt;5)&#123;x++&#125;</span></span><br><span class="line">	x:=<span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> x&lt;<span class="number">5</span>&#123;</span><br><span class="line">		x++</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//相当于while(true)&#123;break&#125;</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for…range 也可以遍历字符串、数组、数组指针、切片、字典、通道类型，返回索引、键值数据。</p>
<p>需要注意一点，range会复制目标数据，这样的话会影响性能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">	data:&#x3D;[3]int&#123;1,2,3&#125;</span><br><span class="line">	for i,x :&#x3D; range data&#123;</span><br><span class="line">		if i&#x3D;&#x3D;0 &#123;</span><br><span class="line">			data[0] +&#x3D;100</span><br><span class="line">			data[1] +&#x3D;100</span><br><span class="line">			data[2] +&#x3D;100</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 输出</span><br><span class="line">		&#x2F;&#x2F; 1 101</span><br><span class="line">		&#x2F;&#x2F; 2 102</span><br><span class="line">		&#x2F;&#x2F; 3 103</span><br><span class="line">		println(x,data[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看输出，i,x都是从data的复制品取出来的，不管data怎么变化，都不会影响到i,x的值。</p>
<p>为了避免每次都复制影响性能，我们可以使用数组指针或切片类型(仅复制slice、不复制底层array)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	data:=[<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i,x := <span class="keyword">range</span> &amp;data&#123;</span><br><span class="line">		<span class="keyword">if</span> i==<span class="number">0</span> &#123;</span><br><span class="line">			data[<span class="number">0</span>] +=<span class="number">100</span></span><br><span class="line">			data[<span class="number">1</span>] +=<span class="number">100</span></span><br><span class="line">			data[<span class="number">2</span>] +=<span class="number">100</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//输出</span></span><br><span class="line">		<span class="comment">//1 101</span></span><br><span class="line">		<span class="comment">//102 102</span></span><br><span class="line">		<span class="comment">//103 103</span></span><br><span class="line">		<span class="built_in">println</span>(x,data[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上输出，因为x在第1次的时候已经赋值了，所以第1次是1</p>
<p>用于终止或跳过的语句是 <code>break</code>、<code>continue</code>，这个不细说了，比较基础。</p>
]]></content>
      <categories>
        <category>Golang 学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>四. Golang中的内建容器</title>
    <url>/2020/05/31/golang_datatypes/</url>
    <content><![CDATA[<h2 id="一-数组-Array"><a href="#一-数组-Array" class="headerlink" title="一. 数组(Array)"></a>一. 数组(Array)</h2><p><strong>定义数组</strong><br>数组的定义不用多说，就是类型相同的数据的集合。<br>GO中的数组比较特殊，纵使都是int类型数据，但如果长度不同的话，类型也不同。<br>如：<code>d1</code>与<code>d2</code>就是不同类型的数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d1 [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> d2 [<span class="number">4</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//会报错</span></span><br><span class="line">d1==d2</span><br></pre></td></tr></table></figure>
<p><strong>初始化数组</strong><br>确定数组容量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//数字在签名，3个int</span></span><br><span class="line">	a:= [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由编译器推断数组容量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b:= [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义多维数组<br>对于”…”的使用，只能用在第一维度</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b:= [...][<span class="number">2</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;</span><br><span class="line">	<span class="comment">//输出了3行2列的数组</span></span><br><span class="line">	fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>len()、cap()<br>对于这两个函数，多维数组的话都是返回一维数组的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b:= [...][<span class="number">2</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;</span><br><span class="line">	<span class="comment">//输出 3 3</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(b),<span class="built_in">cap</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组相等判断</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a:=[<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">	b:=[<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">	<span class="comment">//true</span></span><br><span class="line">	<span class="built_in">println</span>(a==b)</span><br><span class="line"></span><br><span class="line">	c:=[<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>&#125;</span><br><span class="line">	d:=[<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">	<span class="comment">//false</span></span><br><span class="line">	<span class="built_in">println</span>(c==d)</span><br><span class="line"></span><br><span class="line">	m:=[<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	n:=[<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">	<span class="comment">//报错，长度不同，不同类型不能比较</span></span><br><span class="line">	<span class="built_in">println</span>(m==n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组指针</strong><br>数组指针可以获取整个数组的起始地址以及任意数据元素的起始地址。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a:=[<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">	<span class="comment">//0xc00002e768 0xc00002e768 0xc00002e770</span></span><br><span class="line">	<span class="built_in">println</span>(&amp;a,&amp;a[<span class="number">0</span>],&amp;a[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时也可以使用数组指针来直接操作元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a:=[<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">	p:=&amp;a</span><br><span class="line">	p[<span class="number">1</span>]+=<span class="number">10</span></span><br><span class="line">	<span class="comment">//输出12</span></span><br><span class="line">	<span class="built_in">println</span>(p[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历</strong><br>使用for循环遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr3:=[...]<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(arr3);i++ &#123;</span><br><span class="line">		fmt.Println(arr3[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用range遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr3:=[...]<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//i，v都需要</span></span><br><span class="line">	<span class="keyword">for</span> i,v:=<span class="keyword">range</span> arr3&#123;</span><br><span class="line">		fmt.Println(i,v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//仅需要v</span></span><br><span class="line">	<span class="keyword">for</span> _,v:=<span class="keyword">range</span> arr3&#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//仅需要i</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="keyword">range</span> arr3&#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复制</strong><br>数组是值类型，<em>传参</em> 与 <em>赋值</em> 都会进行拷贝，这样比较消耗性能。<br>可以改为指针或切片。</p>
<p>为值传递，纵使<code>changeArray()</code>修改了元素值，但<code>arr</code>在<code>main()</code>中还是没变。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr:=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;</span><br><span class="line">	printArray(arr)</span><br><span class="line">	<span class="comment">//[2,4,6,8,10]</span></span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeArray</span><span class="params">(arr [5]<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	arr[<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改为指针，这样<code>arr</code>在<code>main()</code>中元素就变了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr:=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;</span><br><span class="line">	printArray(&amp;arr)</span><br><span class="line">	<span class="comment">//[100 4 6 8 10]</span></span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArray</span><span class="params">(arr *[5]<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	arr[<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面讲了这么多数组，但go中一般不直接使用数组，使用最多的是切片。</p>
<h2 id="二-切片-Slice"><a href="#二-切片-Slice" class="headerlink" title="二. 切片(Slice)"></a>二. 切片(Slice)</h2><p><strong>Array转换为Slice</strong><br>如下代码，Array转换为Slice时，区间是左闭右开的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//[2 3 4 5]</span></span><br><span class="line">	fmt.Println(<span class="string">"arr[2:6] = "</span>, arr[<span class="number">2</span>:<span class="number">6</span>])</span><br><span class="line">	<span class="comment">//[0 1 2 3 4 5]</span></span><br><span class="line">	fmt.Println(<span class="string">"arr[:6] = "</span>, arr[:<span class="number">6</span>])</span><br><span class="line">	<span class="comment">//[2 3 4 5 6 7]</span></span><br><span class="line">	fmt.Println(<span class="string">"arr[2:] = "</span>, arr[<span class="number">2</span>:])</span><br><span class="line">	<span class="comment">//[0 1 2 3 4 5 6 7]</span></span><br><span class="line">	fmt.Println(<span class="string">"arr[:] = "</span>, arr[:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>官方定义中:slice本身没有数据，是对底层array的一个view(视图)</p>
</blockquote>
<p>如下代码我们看到，slice的改变会影响到array(因为slice是array的一个视图)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">	s1 := arr[<span class="number">2</span>:]</span><br><span class="line">	<span class="comment">// s1 =  [2 3 4 5 6 7]</span></span><br><span class="line">	fmt.Println(<span class="string">"s1 = "</span>, s1)</span><br><span class="line">	s2 := arr[:]</span><br><span class="line">	<span class="comment">//s2 =  [0 1 2 3 4 5 6 7]</span></span><br><span class="line">	fmt.Println(<span class="string">"s2 = "</span>, s2)</span><br><span class="line"></span><br><span class="line">	updateSlice(s1)</span><br><span class="line">	fmt.Println(<span class="string">"After updateSlice(s1)"</span>)</span><br><span class="line">	<span class="comment">//s1 =  [100 3 4 5 6 7]</span></span><br><span class="line">	fmt.Println(<span class="string">"s1 = "</span>, s1)</span><br><span class="line">	<span class="comment">//arr =  [0 1 100 3 4 5 6 7]</span></span><br><span class="line">	fmt.Println(<span class="string">"arr = "</span>, arr)</span><br><span class="line"></span><br><span class="line">	updateSlice(s2)</span><br><span class="line">	fmt.Println(<span class="string">"After updateSlice(s2)"</span>)</span><br><span class="line">	<span class="comment">//s2 =  [100 1 100 3 4 5 6 7]</span></span><br><span class="line">	fmt.Println(<span class="string">"s2 = "</span>, s2)</span><br><span class="line">	<span class="comment">//arr =  [100 1 100 3 4 5 6 7]</span></span><br><span class="line">	fmt.Println(<span class="string">"arr = "</span>, arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Reslice</strong><br>slice可以在slice本身上再slice，也就是reslice</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">	s2 := arr[:]</span><br><span class="line"></span><br><span class="line">	<span class="comment">//[0 1 2 3 4 5 6 7]</span></span><br><span class="line">	fmt.Println(s2)</span><br><span class="line"></span><br><span class="line">	s2 = s2[:<span class="number">5</span>]</span><br><span class="line">	<span class="comment">//[0 1 2 3 4]</span></span><br><span class="line">	fmt.Println(s2)</span><br><span class="line"></span><br><span class="line">	s2 = s2[<span class="number">2</span>:]</span><br><span class="line">	<span class="comment">//[2 3 4]</span></span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>slice的扩展</strong><br>我们看到s1的index从0-3，值为s1=[2,3,4,5]，但s2却为s1的index从3-4，明显超出了s1的index范围，所以s2是s1的扩展。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">	s1 := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">	s2 := s1[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// [2 3 4 5]</span></span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">	<span class="comment">// [5 6]</span></span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>s2也能够正常取值，但直接取s1[4]会报错，因为s1是对array的view，很明显这个view是越界的，所以会报错。<br><img src="http://static.zybuluo.com/ericliu001/2a3jqlbfvhpi8ixh2bglq2ej/image_1e9kdpdhg1nj06r8suu117dkh49.png" alt="image_1e9kdpdhg1nj06r8suu117dkh49.png-117.3kB"></p>
<p><strong>slice的实现</strong><br>slice底层数据结构包含3部分</p>
<ol>
<li>ptr，指向开始元素的地址</li>
<li>len，view的长度</li>
<li>cap，从ptr开始到array结束的长度</li>
</ol>
<p><img src="http://static.zybuluo.com/ericliu001/lp6a5xxhdpldx16jlm674s6i/image_1e9ke4unld651juorajaq51mh7m.png" alt="image_1e9ke4unld651juorajaq51mh7m.png-70.2kB"></p>
<p>结合上面的slice扩展，我们得出结论：</p>
<ul>
<li>slice可以向后扩展，不可以向前扩展</li>
<li>s[i]不可以超越len(s)，向后扩展不可以超越底层数组cap(s)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">	s1 := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">	s2 := s1[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">//s1=[2 3 4 5], len(s1)=4 ,cap(s1)=6</span></span><br><span class="line">	fmt.Printf(<span class="string">"s1=%v, len(s1)=%d ,cap(s1)=%d\n"</span>, s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">	<span class="comment">//s2=[5 6], len(s2)=2 ,cap(s2)=3</span></span><br><span class="line">	fmt.Printf(<span class="string">"s2=%v, len(s2)=%d ,cap(s2)=%d\n"</span>, s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>向slice添加元素</strong><br>我们可以使用<code>append()</code>向slice添加元素，因为值传递的关系，必须接收<code>append()</code>返回的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr1 := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">	s1 := arr1[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// s2 = [5 6]</span></span><br><span class="line">	s2 := s1[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// s3 = [5 6 10]</span></span><br><span class="line">	s3 := <span class="built_in">append</span>(s2, <span class="number">10</span>)</span><br><span class="line">	<span class="comment">// s4 = [5 6 10 11]</span></span><br><span class="line">	s4 := <span class="built_in">append</span>(s3, <span class="number">11</span>)</span><br><span class="line">	<span class="comment">// s5 = [5 6 10 11 12]</span></span><br><span class="line">	s5 := <span class="built_in">append</span>(s4, <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(s3, s4, s5)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// arr = [0 1 2 3 4 5 6 10]</span></span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码我们看到，s3是在s2的基础上添加了元素10，此时还没有超出s2的cap，所以s3还是对arr1的view，并且arr1的最后1个元素从7变为了10</p>
<p>但s4显然超出了s3的cap，s4会重新开辟一块连续的内存(数组)，内存容量会是arr1的二倍，然后将s3复制到新的数组中，再进行append操作。</p>
<p><strong>创建slice</strong><br>使用var定义1个slice，此时slice的zero value为nil<br>下面代码我们向s插入100个数，s的初始化cap与len为0，但随着len==cap但继续向s插入元素，cap会扩充为之前的2倍形成新的数组，s会进行元素的复制以及ptr的指向。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="keyword">int</span> <span class="comment">//zero value for slice is nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		printSlice(s)</span><br><span class="line">		s = <span class="built_in">append</span>(s, <span class="number">2</span>*i+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面创建slice的方式很简单，但是由于数组的动态创建、扩充，会比较消耗性能。如果我们提前知道数组的大致cap，可以使用<code>make()</code>创建一个比较大的slice。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">	<span class="comment">//[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0],len=16,cap=16</span></span><br><span class="line">	fmt.Printf(<span class="string">"%v,len=%d,cap=%d\n"</span>, s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line"></span><br><span class="line">	s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">32</span>)</span><br><span class="line">	<span class="comment">//[0 0 0 0 0 0 0 0 0 0],len=10,cap=32</span></span><br><span class="line">	fmt.Printf(<span class="string">"%v,len=%d,cap=%d\n"</span>, s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>copy slice</strong><br>使用<code>copy()</code>可以进行slice的copy</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s0 := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line">	s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">	<span class="built_in">copy</span>(s1, s0)</span><br><span class="line">	<span class="comment">//[2 4 6 8 0 0 0 0 0 0 0 0 0 0 0 0],len=16,cap=16</span></span><br><span class="line">	fmt.Printf(<span class="string">"%v,len=%d,cap=%d\n"</span>, s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>delete slice</strong><br>go中没有删除slice元素的内建函数，我们可以使用<code>append()</code></p>
<ol>
<li>对被删除元素的前面元素切片执行<code>append()</code></li>
<li>append内容为被删除元素的后面元素的内容，需要使用”…”</li>
</ol>
<p>比如我们要删除元素6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	s0 :&#x3D; []int&#123;2, 4, 6, 8&#125;</span><br><span class="line">	s1 :&#x3D; make([]int, 16, 16)</span><br><span class="line">	copy(s1, s0)</span><br><span class="line">	&#x2F;&#x2F;[2 4 6 8 0 0 0 0 0 0 0 0 0 0 0 0],len&#x3D;16,cap&#x3D;16</span><br><span class="line">	fmt.Printf(&quot;%v,len&#x3D;%d,cap&#x3D;%d\n&quot;, s1, len(s1), cap(s1))</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;[2 4 8 0 0 0 0 0 0 0 0 0 0 0 0],len&#x3D;15,cap&#x3D;16</span><br><span class="line">	s1 &#x3D; append(s1[:2], s1[3:]...) &#x2F;&#x2F;s1是reslice</span><br><span class="line">	fmt.Printf(&quot;%v,len&#x3D;%d,cap&#x3D;%d\n&quot;, s1, len(s1), cap(s1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-Map"><a href="#三-Map" class="headerlink" title="三. Map"></a>三. Map</h2><p><strong>map的定义</strong><br>map定位为<code>map[k]v</code>的形式，可以使用make创建，或其他方式创建。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//m0 = nil</span></span><br><span class="line">	<span class="keyword">var</span> m0 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//m1 = map[course:golang name:eric quality:good]</span></span><br><span class="line">	m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"name"</span>:    <span class="string">"eric"</span>,</span><br><span class="line">		<span class="string">"course"</span>:  <span class="string">"golang"</span>,</span><br><span class="line">		<span class="string">"quality"</span>: <span class="string">"good"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//m2 = map[]</span></span><br><span class="line">	m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(m0, m1, m2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>map的遍历</strong><br>map使用range进行遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//m1 = map[course:golang name:eric quality:good]</span></span><br><span class="line">	m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"name"</span>:    <span class="string">"eric"</span>,</span><br><span class="line">		<span class="string">"course"</span>:  <span class="string">"golang"</span>,</span><br><span class="line">		<span class="string">"quality"</span>: <span class="string">"good"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//k,v遍历</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//只有k的遍历</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">		fmt.Println(k)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map的遍历是无序的(k,v无序)，第一次与第二次遍历顺序可能不一样。</p>
<p><strong>获取map元素</strong><br>对于不存在的key，获取的元素为zeroValue，不会报错。<br>我们通常状态码来判断key是否存在，存在的话获取正确value</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//m1 = map[course:golang name:eric quality:good]</span></span><br><span class="line">	m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"name"</span>:    <span class="string">"eric"</span>,</span><br><span class="line">		<span class="string">"course"</span>:  <span class="string">"golang"</span>,</span><br><span class="line">		<span class="string">"quality"</span>: <span class="string">"good"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过ok来判断</span></span><br><span class="line">	<span class="keyword">if</span> course, ok := m1[<span class="string">"course"</span>]; ok &#123;</span><br><span class="line">		fmt.Println(course)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"key does not exist"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除元素</strong><br>使用<code>delete()</code>函数删除，如下删除map中key=name的元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//m1 = map[course:golang name:eric quality:good]</span></span><br><span class="line">	m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"name"</span>:    <span class="string">"eric"</span>,</span><br><span class="line">		<span class="string">"course"</span>:  <span class="string">"golang"</span>,</span><br><span class="line">		<span class="string">"quality"</span>: <span class="string">"good"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除name值</span></span><br><span class="line">	<span class="built_in">delete</span>(m1, <span class="string">"name"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//map[course:golang quality:good]</span></span><br><span class="line">	fmt.Println(m1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-字符串-String"><a href="#四-字符串-String" class="headerlink" title="四. 字符串(String)"></a>四. 字符串(String)</h2><p>字符串的默认值是””，不是nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">	<span class="comment">//true</span></span><br><span class="line">	<span class="built_in">println</span>(s==<span class="string">""</span>)</span><br><span class="line">	<span class="comment">//错误</span></span><br><span class="line">	<span class="built_in">println</span>(s==<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用命令执行符”`”可以定义不做转义处理的原始字符串(格式保留)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	s:=<span class="string">`line\r\n,</span></span><br><span class="line"><span class="string">line 2`</span></span><br><span class="line">	<span class="built_in">println</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">line\r\n,</span><br><span class="line">line <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>字符串使用”+”连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;跨行时，&quot;+&quot;必须在上一行结尾</span><br><span class="line">s:&#x3D;&quot;ab&quot;+</span><br><span class="line">   &quot;cd&quot;</span><br></pre></td></tr></table></figure>

<p><strong>字节数组</strong><br>GO允许以索引号访问字节数组(数字非字符)，但不能获取元素地址</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	s:=<span class="string">"abcd"</span></span><br><span class="line">	<span class="comment">//输出98，即b</span></span><br><span class="line">	<span class="built_in">println</span>(s[<span class="number">1</span>])</span><br><span class="line">	<span class="comment">//报错</span></span><br><span class="line">	<span class="built_in">println</span>(&amp;s[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以切片方式访问字节数组，其内部还是指向原字节数组，只是len不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">	s:&#x3D;&quot;abcde&quot;</span><br><span class="line">	&#x2F;&#x2F;abc</span><br><span class="line">	s1:&#x3D;s[:3]</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;bcd</span><br><span class="line">	s2:&#x3D;s[1:4]</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;cde</span><br><span class="line">	s3:&#x3D;s[2:]</span><br><span class="line"></span><br><span class="line">	println(s1,s2,s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，s与s1、s2、s3指向的内存地址相同，但len不同。</p>
<p><strong>遍历字符串</strong><br>遍历字符串分2种情况：byte、rune</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">"Yes我爱中国"</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//byte方式遍历 会出现乱码</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		<span class="comment">//(0 Y)(1 e)(2 s)(3 æ)(4 )(5 )(6 ç)(7 )(8 ±)(9 ä)(10 ¸)(11 ­)(12 å)(13 )(14 ½)</span></span><br><span class="line">		fmt.Printf(<span class="string">"(%d %c)"</span>, i, s[i])</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认rune方式，但是i是字节的开始位置</span></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="comment">//(0 Y)(1 e)(2 s)(3 我)(6 爱)(9 中)(12 国)</span></span><br><span class="line">		fmt.Printf(<span class="string">"(%d %c)"</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将s转换为rune切片的方式(重新开辟了rune数组存储字符)，i就是第几个字符了</span></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> []<span class="keyword">rune</span>(s) &#123;</span><br><span class="line">		<span class="comment">//(0 Y)(1 e)(2 s)(3 我)(4 爱)(5 中)(6 国)</span></span><br><span class="line">		fmt.Printf(<span class="string">"(%d %c)"</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: ä</span><br><span class="line"><span class="number">1</span>: ¸</span><br><span class="line"><span class="number">2</span>: ­</span><br><span class="line"><span class="number">3</span>: å</span><br><span class="line"><span class="number">4</span>: </span><br><span class="line"><span class="number">5</span>: ½</span><br><span class="line"><span class="number">0</span>: 中</span><br><span class="line"><span class="number">3</span>: 国</span><br></pre></td></tr></table></figure>

<p><strong>性能问题</strong><br>用+进行字符串拼接时，每次都得重新分配内存。当然一两次的字符串连接没有问题，但在构建超大字符串时性能就很差了。</p>
<p>每次都分配内存</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkTest</span><span class="params">(b *testing.B)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">		s+=<span class="string">"a"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：每次操作需要53839纳秒</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">BenchmarkTest<span class="number">-4</span>   	  <span class="number">873931</span>	     <span class="number">53839</span> ns/op</span><br></pre></td></tr></table></figure>

<p>改进：提前预分配一块大slice内存，最后再join</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkTest</span><span class="params">(b *testing.B)</span></span>  &#123;</span><br><span class="line">	s:=<span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="number">100000</span>)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">		s=<span class="built_in">append</span>(s,<span class="string">"a"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	strings.Join(s,<span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：每次操作需要146纳秒</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">BenchmarkTest<span class="number">-4</span>   	 <span class="number">8978041</span>	       <span class="number">146</span> ns/op</span><br></pre></td></tr></table></figure>

<p><strong>rune</strong><br>rune专门用来存储Unicode，使用单引号的字面量，默认是rune类型。</p>
<p>标准库Unicode提供了丰富的操作函数，比如使用代替len返回准确的Unicode字符梳理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	s:=<span class="string">"中国!"</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="built_in">len</span>(s),utf8.RuneCountInString(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Golang 学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>三. Golang中的函数</title>
    <url>/2020/05/31/golang_functions/</url>
    <content><![CDATA[<h2 id="一-声明"><a href="#一-声明" class="headerlink" title="一. 声明"></a>一. 声明</h2><p>使用func关键字即可，且左花括号不能另起一行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二-参数"><a href="#二-参数" class="headerlink" title="二. 参数"></a>二. 参数</h2><p>go语言不支持默认参数，如下面是错误的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="keyword">int</span> = 5)</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值拷贝传递。不论是指针、引用，都是值拷贝传递，只不过是拷贝目标对象，还是拷贝指针的区别。</p>
<p><strong>拷贝目标对象</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">	a:&#x3D;5</span><br><span class="line">	fmt.Printf(&quot;pointer:%p target:%v \n&quot;,&amp;a,a)</span><br><span class="line">	test(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test(x int)  &#123;</span><br><span class="line">	fmt.Printf(&quot;pointer:%p target:%v \n&quot;,&amp;x,x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pointer:0xc0000b4008 target:5 </span><br><span class="line">pointer:0xc0000b4020 target:5</span><br></pre></td></tr></table></figure>
<p>我们看内存地址发生了变更，所以拷贝了对象。</p>
<p><strong>拷贝指针</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	a:=<span class="number">5</span></span><br><span class="line">	p:=&amp;a</span><br><span class="line">	fmt.Printf(<span class="string">"pointer: %p，target：%v\n"</span>,&amp;p,p)</span><br><span class="line"></span><br><span class="line">	test(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x *<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"pointer: %p，target：%v\n"</span>,&amp;x,x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pointer: 0xc0000ae018，target：0xc0000b4008</span><br><span class="line">pointer: 0xc0000ae028，target：0xc0000b4008</span><br></pre></td></tr></table></figure>
<p>可见，调用函数test()时，指针中存的“地址”被拷贝了，所以pointer不同；但拷贝的内容肯定一样，所以target相同。</p>
<p><strong>变参</strong><br>变参本质上是一个切片，只能接收一到多个同类型参数，且必须放在列表尾部。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	myTest(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myTest</span><span class="params">(a ...<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span> _,v:=<span class="keyword">range</span> a&#123;</span><br><span class="line">		<span class="built_in">println</span>(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Best Practice</strong><br>如果函数参数太多，可以放到结构体内，同时也能变相的实现默认值传参。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	option:=newOption()</span><br><span class="line">	option.port=<span class="number">8080</span></span><br><span class="line">	server(option)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//server选项结构体(参数列表)</span></span><br><span class="line"><span class="keyword">type</span> serverOption <span class="keyword">struct</span> &#123;</span><br><span class="line">	address <span class="keyword">string</span></span><br><span class="line">	port <span class="keyword">int</span></span><br><span class="line">	path <span class="keyword">string</span></span><br><span class="line">	timeout time.Duration</span><br><span class="line">	log *log.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取参数(同时初始化)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newOption</span><span class="params">()</span> *<span class="title">serverOption</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;serverOption&#123;</span><br><span class="line">		address: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">		port: <span class="number">80</span>,</span><br><span class="line">		path: <span class="string">"/var/text"</span>,</span><br><span class="line">		timeout: time.Second*<span class="number">5</span>,</span><br><span class="line">		log: <span class="literal">nil</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//server服务器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">(option *serverOption)</span></span>  &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-返回值"><a href="#三-返回值" class="headerlink" title="三. 返回值"></a>三. 返回值</h2><p><strong>函数可以有多个返回值</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	age,name:=myTest()</span><br><span class="line">	<span class="built_in">println</span>(name,age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myTest</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">28</span>,<span class="string">"eric"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同时也可以对返回值命名</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	age,name:=myTest()</span><br><span class="line">	<span class="built_in">println</span>(name,age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myTest</span><span class="params">()</span><span class="params">(age <span class="keyword">int</span>,name <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">	age = <span class="number">28</span></span><br><span class="line">	name = <span class="string">"eric"</span></span><br><span class="line">	<span class="keyword">return</span> <span class="comment">//相当于 return age,name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-匿名函数"><a href="#四-匿名函数" class="headerlink" title="四. 匿名函数"></a>四. 匿名函数</h2><p>匿名函数是指没有名字符号的函数，除没有名字外，匿名函数和普通函数的功能完全相同。但匿名函数有很多用法：</p>
<ol>
<li>普通函数中直接调用匿名函数</li>
<li>匿名函数可以保存到变量调用</li>
<li>匿名函数可以作为函数参数</li>
<li>匿名函数可以作为函数返回值</li>
</ol>
<p><strong>直接调用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出hello world</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">		<span class="built_in">println</span>(s)</span><br><span class="line">	&#125;(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>保存变量</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	add:= <span class="function"><span class="keyword">func</span><span class="params">(x,y <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x+y</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(add(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数参数</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	test(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	    <span class="built_in">println</span>(<span class="string">"hello world"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(f <span class="keyword">func</span>()</span>)</span>  &#123;</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数返回值</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	add:=test()</span><br><span class="line">	<span class="built_in">println</span>(add(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x+y</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名函数是一种常见的重构手段，可将大函数分解为多个相对独立的匿名函数块，然后用相对简洁的调用完成逻辑流程。</p>
<p>相比语句块，匿名函数的作用域被隔离，不会引发外部污染，更加灵活。</p>
<h2 id="五-延迟调用"><a href="#五-延迟调用" class="headerlink" title="五. 延迟调用"></a>五. 延迟调用</h2><p>语句defer向当前函数注册稍后执行的函数调用，当前函数执行完才进行调用，常用于资源释放、错误处理等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	f,err:=os.Open(<span class="string">"./main.go"</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放资源</span></span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>FILO</strong><br>延迟调用时FILO的顺序，先进后出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出b、a</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">"a"</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">"b"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>性能</strong><br>defer要进行注册、调用等操作，还要额外的缓存开销，性能不怎么样。<br>我们对比下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	m.Lock()</span><br><span class="line">	m.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//延迟调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferCall</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试直接调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCall</span><span class="params">(b *testing.B)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">		call()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试延迟调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDefer</span><span class="params">(b *testing.B)</span></span>  &#123;</span><br><span class="line">	deferCall()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;直接调用</span><br><span class="line">BenchmarkCall-4   	93716590	        12.5 ns&#x2F;op</span><br><span class="line">&#x2F;&#x2F;延迟调用</span><br><span class="line">BenchmarkDefer-4   	1000000000	         0.000000 ns&#x2F;op</span><br></pre></td></tr></table></figure>

<p>结果差了这么多，defer性能真的不太行啊。</p>
<h2 id="六-错误处理"><a href="#六-错误处理" class="headerlink" title="六. 错误处理"></a>六. 错误处理</h2><p>go通过返回error状态来判断是否出错，标准库将error定义为接口类型。</p>
<p><strong>基本使用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义错误变量，其实就是错误码</span></span><br><span class="line"><span class="keyword">var</span> errDivByZero = errors.New(<span class="string">"division by zero"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(x,y <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>,error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> y==<span class="number">0</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>,errDivByZero</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x/y,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	z,err := div(<span class="number">5</span>,<span class="number">0</span>)</span><br><span class="line">	<span class="comment">//判断是否等于上面错误变量，其实就是错误码</span></span><br><span class="line">	<span class="keyword">if</span> err == errDivByZero&#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义错误类型</strong><br>自定义错误类型可以容纳更多的上下文信息，也可以给予类型做判断(错误有类型了)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义DivError类型</span></span><br><span class="line"><span class="keyword">type</span> DivError <span class="keyword">struct</span> &#123;</span><br><span class="line">	x,y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定Error()方法到DivError</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(DivError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"div by zero"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ducktype，DivError是error类型，但DivError中有x,y成员变量了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(x,y <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>,error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> y==<span class="number">0</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>,DivError&#123;x,y&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x/y,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	z,err := div(<span class="number">5</span>,<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> e:=err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> DivError:</span><br><span class="line">			<span class="comment">//打印错误的同时也打印成员变量</span></span><br><span class="line">			fmt.Println(e,e.x,e.y)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(e)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(z)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>panic、recover</strong><br>panic 相当于php中的<code>throw</code>、recover相当于php中的<code>catch</code>。<br>示例如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		if err:&#x3D;recover();err!&#x3D;nil&#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	panic(&quot;i am dead&quot;)</span><br><span class="line">	&#x2F;&#x2F;永远不会被执行，相当于上面抛出了异常</span><br><span class="line">	println(&quot;hello world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但有一点，不管defer有没有被recover，defer都会执行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"aaa"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"i am dead"</span>)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的会输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaa</span><br><span class="line">i am dead</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议：除非是不可恢复性、导致系统无法正常工作的错误，如端口占用、数据库未启动等系统级错误，否则不建议使用panic。</p>
</blockquote>
]]></content>
      <categories>
        <category>Golang 学习笔记</category>
      </categories>
  </entry>
</search>
