<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/05/03/Hello-World/</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>我是一个coder，但很多时候又不像coder；我着迷这个世界的多样性，但有时候也被多样的世界搞得晕头转向。</p>
<p>初次相见，一如往常：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Hello,world!"</span>;</span><br></pre></td></tr></table></figure>

<h1 id="子路说"><a href="#子路说" class="headerlink" title="子路说"></a>子路说</h1><p>新开博客实在也没想到好名字，“简约但不简单”是我喜欢的风格，媳妇突发奇想：<strong>“子路说”</strong>。嗯…简单且带有淡淡的诗意，好名字。</p>
<h1 id="左手代码右手诗"><a href="#左手代码右手诗" class="headerlink" title="左手代码右手诗"></a>左手代码右手诗</h1><p>左手代码右手诗，很高兴认识你<strong>:)</strong></p>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>Wireshark实战Keep-Alive</title>
    <url>/2020/05/10/keep-alive/</url>
    <content><![CDATA[<p>HTTP在我们的生产实践中至关重要，HTTP协议就像水与空气一般，太常见了但又无时无刻不存在。<br>后面打算写一系列HTTP总结的文章，以期能够真正理解掌握HTTP，今天我们就以Keep-Alive开始吧！</p>
<h2 id="一、What-Keep-Alive"><a href="#一、What-Keep-Alive" class="headerlink" title="一、What Keep-Alive"></a>一、What Keep-Alive</h2><p>Keep-Alive见名知意：即 <strong>保持存在，</strong>在网络中也就是“<strong>保持连接”</strong>的意思。</p>
<p>在http性能优化中keep-alive至关重要，今天我们就来深入了解实战下吧！</p>
<h2 id="二、Why-Keep-Alive"><a href="#二、Why-Keep-Alive" class="headerlink" title="二、Why Keep-Alive"></a>二、Why Keep-Alive</h2><p>我们都知道，Http属于应用层协议，其是建立在TCP/IP网络模型上进行数据传输。</p>
<p>短连接与长连接的区别如图：</p>
<p><img src="http://static.zybuluo.com/ericliu001/bq7a5bxfcmg1preqhch87zcg/image.png" alt="image.png-428.6kB"></p>
<p>如果是短连接的话，每次 <strong>请求前</strong> 都要TCP建立连接、每次 <strong>响应后</strong> 都要TCP断开连接。</p>
<p>如果是长连接的话，纵使N次 <strong>请求-响应</strong>，只需在第一次发送 <strong>请求前</strong> 建立TCP连接，最后一次 <strong>响应后</strong> 断开连接。</p>
<hr>
<p>我们知道TCP三次握手、四次挥手是比较昂贵的时间资源，短连接场景下每次HTTP连接都要经历这个过程，那么，这个连接为什么不能复用呢？</p>
<p> 长连接在HTTP 1.1应运而生，即Keep-Alive。</p>
<h2 id="三、How-Keep-Alive"><a href="#三、How-Keep-Alive" class="headerlink" title="三、How Keep-Alive"></a>三、How Keep-Alive</h2><p>Keep-Alive功能需要Client与Server同时支持才可以，下面我们使用3个工具演示Keep-Alive的过程</p>
<ol>
<li>WireShark</li>
<li>Nginx</li>
<li>Curl</li>
</ol>
<p>Nginx安装我们就不细说了，来看一下Nginx的配置吧：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	  <span class="comment"># 空闲连接的超时时间</span></span><br><span class="line">		keepalive_timeout  <span class="number">60</span>s;</span><br><span class="line">		<span class="comment"># 长连接上可发送的最大请求数，为了实验我们设置为3</span></span><br><span class="line">		keepalive_requests <span class="number">3</span>;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen <span class="number">80</span>;</span><br><span class="line">        location / &#123;</span><br><span class="line">            default_type text/html;</span><br><span class="line">            content_by_lua_block &#123;</span><br><span class="line">                ngx.say(<span class="string">"&lt;p&gt;hello2, world&lt;/p&gt;"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置中有两个参数至关重要:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">keepalive_timeout,设置长连接的超时时间，如果一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源</span><br><span class="line">keepalive_requests，指长连接上发送的最大请求数</span><br></pre></td></tr></table></figure>

<hr>
<p>到这里默认你的Nginx，也就是Server已经根据上述配置启动成功了，我们接下来编写一段Client请求测试代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> $ch = curl_init();</span><br><span class="line"> curl_setopt($ch, CURLOPT_URL, <span class="string">"http://localhost"</span>);</span><br><span class="line"> curl_setopt($ch, CURLOPT_HEADER, <span class="keyword">false</span>);</span><br><span class="line"> curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"> <span class="comment">//第1次请求</span></span><br><span class="line"> curl_exec($ch);</span><br><span class="line"> <span class="comment">//第2次请求</span></span><br><span class="line"> curl_exec($ch);</span><br><span class="line"> <span class="comment">//第3次请求</span></span><br><span class="line"> curl_exec($ch);</span><br><span class="line"> <span class="comment">//第4次请求</span></span><br><span class="line"> curl_exec($ch);</span><br><span class="line"> <span class="comment">//关闭连接</span></span><br><span class="line"> curl_close($ch);</span><br></pre></td></tr></table></figure>

<p>为什么要编写这段代码呢，直接命令行多次执行curl命令不行吗？</p>
<p>答案是不行的，为什么呢？因为我试过，哈哈。命令行执行curl时无法保持长连接的。</p>
<hr>
<p>好了，Server、Client我们完成，接下来我们打开wireshark等待鱼上钩。</p>
<p>我们执行Client测试代码，WireShark抓包如下</p>
<p><img src="http://static.zybuluo.com/ericliu001/scxmgn17apu4x4jfkk56saxr/image.png" alt="image.png-338.4kB"></p>
<p>我们看到，3次请求之后，TCP就断开了连接，第4次请求重新建立连接，为什么呢？</p>
<p>还记得我们配置<code>keepalive_requests 3</code>这个参数吗？对，在发送请求3次后断开连接，就是这个意思。</p>
<p>如此，我们看到，Keep-Alive确实起作用了，这样网络传输性能就提高了很多。</p>
<p>Enjoy！：）</p>
]]></content>
      <categories>
        <category>HTTP Learning</category>
      </categories>
  </entry>
</search>
