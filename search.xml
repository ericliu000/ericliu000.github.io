<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/05/03/Hello-World/</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>我是一个coder，但很多时候又不像coder；我着迷这个世界的多样性，但有时候也被多样的世界搞得晕头转向。</p>
<p>初次相见，一如往常：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Hello,world!"</span>;</span><br></pre></td></tr></table></figure>

<h1 id="子路说"><a href="#子路说" class="headerlink" title="子路说"></a>子路说</h1><p>新开博客实在也没想到好名字，“简约但不简单”是我喜欢的风格，媳妇突发奇想：<strong>“子路说”</strong>。嗯…简单且带有淡淡的诗意，好名字。</p>
<h1 id="左手代码右手诗"><a href="#左手代码右手诗" class="headerlink" title="左手代码右手诗"></a>左手代码右手诗</h1><p>左手代码右手诗，很高兴认识你<strong>:)</strong></p>
]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
  </entry>
  <entry>
    <title>Wireshark实战Keep-Alive</title>
    <url>/2020/05/10/keep-alive/</url>
    <content><![CDATA[<p>HTTP在我们的生产实践中至关重要，HTTP协议就像水与空气一般，太常见了但又无时无刻不存在。<br>后面打算写一系列HTTP总结的文章，以期能够真正理解掌握HTTP，今天我们就以Keep-Alive开始吧！</p>
<h2 id="一、What-Keep-Alive"><a href="#一、What-Keep-Alive" class="headerlink" title="一、What Keep-Alive"></a>一、What Keep-Alive</h2><p>Keep-Alive见名知意：即 <strong>保持存在，</strong>在网络中也就是“<strong>保持连接”</strong>的意思。</p>
<p>在http性能优化中keep-alive至关重要，今天我们就来深入了解实战下吧！</p>
<h2 id="二、Why-Keep-Alive"><a href="#二、Why-Keep-Alive" class="headerlink" title="二、Why Keep-Alive"></a>二、Why Keep-Alive</h2><p>我们都知道，Http属于应用层协议，其是建立在TCP/IP网络模型上进行数据传输。</p>
<p>短连接与长连接的区别如图：</p>
<p><img src="http://static.zybuluo.com/ericliu001/bq7a5bxfcmg1preqhch87zcg/image.png" alt="image.png-428.6kB"></p>
<p>如果是短连接的话，每次 <strong>请求前</strong> 都要TCP建立连接、每次 <strong>响应后</strong> 都要TCP断开连接。</p>
<p>如果是长连接的话，纵使N次 <strong>请求-响应</strong>，只需在第一次发送 <strong>请求前</strong> 建立TCP连接，最后一次 <strong>响应后</strong> 断开连接。</p>
<hr>
<p>我们知道TCP三次握手、四次挥手是比较昂贵的时间资源，短连接场景下每次HTTP连接都要经历这个过程，那么，这个连接为什么不能复用呢？</p>
<p> 长连接在HTTP 1.1应运而生，即Keep-Alive。</p>
<h2 id="三、How-Keep-Alive"><a href="#三、How-Keep-Alive" class="headerlink" title="三、How Keep-Alive"></a>三、How Keep-Alive</h2><p>Keep-Alive功能需要Client与Server同时支持才可以，下面我们使用3个工具演示Keep-Alive的过程</p>
<ol>
<li>WireShark</li>
<li>Nginx</li>
<li>Curl</li>
</ol>
<p>Nginx安装我们就不细说了，来看一下Nginx的配置吧：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    <span class="comment"># 空闲连接的超时时间</span></span><br><span class="line">    keepalive_timeout  <span class="number">60</span>s;</span><br><span class="line">    <span class="comment"># 长连接上可发送的最大请求数，为了实验我们设置为3</span></span><br><span class="line">    keepalive_requests <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        listen <span class="number">80</span>;</span><br><span class="line">        location / &#123;</span><br><span class="line">            default_type text/html;</span><br><span class="line">            content_by_lua_block &#123;</span><br><span class="line">                ngx.say(<span class="string">"&lt;p&gt;hello, world&lt;/p&gt;"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置中有两个参数至关重要:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">keepalive_timeout,设置长连接的超时时间，如果一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源</span><br><span class="line">keepalive_requests，指长连接上发送的最大请求数</span><br></pre></td></tr></table></figure>

<hr>
<p>到这里默认你的Nginx，也就是Server已经根据上述配置启动成功了，我们接下来编写一段Client请求测试代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> $ch = curl_init();</span><br><span class="line"> curl_setopt($ch, CURLOPT_URL, <span class="string">"http://localhost"</span>);</span><br><span class="line"> curl_setopt($ch, CURLOPT_HEADER, <span class="keyword">false</span>);</span><br><span class="line"> curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"> <span class="comment">//第1次请求</span></span><br><span class="line"> curl_exec($ch);</span><br><span class="line"> <span class="comment">//第2次请求</span></span><br><span class="line"> curl_exec($ch);</span><br><span class="line"> <span class="comment">//第3次请求</span></span><br><span class="line"> curl_exec($ch);</span><br><span class="line"> <span class="comment">//第4次请求</span></span><br><span class="line"> curl_exec($ch);</span><br><span class="line"> <span class="comment">//关闭连接</span></span><br><span class="line"> curl_close($ch);</span><br></pre></td></tr></table></figure>

<p>为什么要编写这段代码呢，直接命令行多次执行curl命令不行吗？</p>
<p>答案是不行的，为什么呢？因为我试过，哈哈。命令行执行curl时无法保持长连接的。</p>
<hr>
<p>好了，Server、Client我们完成，接下来我们打开wireshark等待鱼上钩。</p>
<p>我们执行Client测试代码，WireShark抓包如下</p>
<p><img src="http://static.zybuluo.com/ericliu001/scxmgn17apu4x4jfkk56saxr/image.png" alt="image.png-338.4kB"></p>
<p>我们看到，3次请求之后，TCP就断开了连接，第4次请求重新建立连接，为什么呢？</p>
<p>还记得我们配置<code>keepalive_requests 3</code>这个参数吗？对，在发送请求3次后断开连接，就是这个意思。</p>
<p>如此，我们看到，Keep-Alive确实起作用了，这样网络传输性能就提高了很多。</p>
<p>Enjoy！：）</p>
]]></content>
      <categories>
        <category>HTTP Learning</category>
      </categories>
  </entry>
  <entry>
    <title>一. Golang中的类型</title>
    <url>/2020/05/31/golang_types/</url>
    <content><![CDATA[<h2 id="一-变量"><a href="#一-变量" class="headerlink" title="一. 变量"></a>一. 变量</h2><h3 id="1-变量定义"><a href="#1-变量定义" class="headerlink" title="1.变量定义"></a>1.变量定义</h3><p>关键字<code>var</code>定义变量，且类型放在变量名后面，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p>先想到变量名再想到变量类型，这样更加符合我们的思维模式。<br>变量在声明时会被初始化为zero value，避免出现不可预测的行为。</p>
<h3 id="2-类型推断"><a href="#2-类型推断" class="headerlink" title="2.类型推断"></a>2.类型推断</h3><p>如果在声明变量时显示的赋值，可以省略变量类型，由编译器进行推断。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"eric"</span></span><br></pre></td></tr></table></figure>
<h3 id="3-简短模式"><a href="#3-简短模式" class="headerlink" title="3.简短模式"></a>3.简短模式</h3><p>更加简洁的方式定义变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name := <span class="string">"eric"</span></span><br></pre></td></tr></table></figure>
<p>简短模式很方便，但也有一些限制：</p>
<ul>
<li>只能函数内部使用</li>
<li>必须显示初始化</li>
<li>不能提供数据类型</li>
</ul>
<p>简短模式也可能带来一些风险，需要注意：比如原本打算修改全局变量，但不小心用简短模式将全局变量进行了重新定义并覆盖。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestVariable</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">	t.Log(&amp;x,x) <span class="comment">//0x1225290 100</span></span><br><span class="line">	x := <span class="string">"david"</span></span><br><span class="line">	t.Log(&amp;x,x) <span class="comment">//0xc00008e4f0 david</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简短模式有时候也会退化为赋值操作，比如这样写是错的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestVariable</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">	name := <span class="string">"eric"</span></span><br><span class="line">	name := <span class="string">"david"</span> <span class="comment">//抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这样写是对的(退化为赋值操作)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestVariable</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">	name := <span class="string">"eric"</span></span><br><span class="line">	name, age := <span class="string">"david"</span>, <span class="number">28</span> <span class="comment">//此时退化成了赋值操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种退化有时候很有用，比如允许我们重复使用err变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestVariable</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">	f, err := os.open(<span class="string">"/tmp/tmp.log"</span>)</span><br><span class="line">	...</span><br><span class="line">	n,err := f.Read(buf) <span class="comment">//err退化为赋值操作，n新定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-一次定义多个变量"><a href="#4-一次定义多个变量" class="headerlink" title="4.一次定义多个变量"></a>4.一次定义多个变量</h3><p>为了“偷懒”，我们可以一次定义多个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x, name = <span class="number">3</span>, <span class="string">"eric"</span></span><br><span class="line">x, name := <span class="number">3</span>, <span class="string">"eric"</span></span><br></pre></td></tr></table></figure>

<p>同时建议我们以组的方式整理多行变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">10</span></span><br><span class="line">x, name := <span class="number">3</span>, <span class="string">"eric"</span></span><br></pre></td></tr></table></figure>

<h3 id="5-多变量赋值"><a href="#5-多变量赋值" class="headerlink" title="5.多变量赋值"></a>5.多变量赋值</h3><p>在没有多变量赋值前，我们交换x,y的值总需要借助tmp变量来完成，现在不用了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func TestVariable(t *testing.T)  &#123;</span><br><span class="line">	x, y :&#x3D; 10, 20</span><br><span class="line">	x ,y &#x3D; y, x &#x2F;&#x2F; 交换后 x &#x3D; 20，y&#x3D;10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>机制就是做多变量赋值时，会先计算出所有右值，然后依次完成左值得赋值操作。<br>下面也是一样道理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">	x, y :&#x3D; 1, 2</span><br><span class="line">	x, y &#x3D; y+2 ,x+5 &#x2F;&#x2F;先计算y+2，x+5的值再赋给左边，所以完成后是x&#x3D;4,y&#x3D;6</span><br><span class="line">	println(x,y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-空占位符"><a href="#6-空占位符" class="headerlink" title="6.空占位符"></a>6.空占位符</h3><p>未使用的局部变量会造成编译不通过，这有助于养成良好的编程习惯。</p>
<p>但有时候我们也需要规避编译器对未使用变量的检查，这就用到了“_”占位符.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x, _ :&#x3D; strconv.Atoi(&quot;12&quot;) &#x2F;&#x2F;忽略Atoi的err返回值</span><br></pre></td></tr></table></figure>

<h2 id="二-常量"><a href="#二-常量" class="headerlink" title="二. 常量"></a>二. 常量</h2><h3 id="1-常量定义"><a href="#1-常量定义" class="headerlink" title="1.常量定义"></a>1.常量定义</h3><p>常量表示运行期恒定不可变的值，通常是字面量，目的是消除magic number。</p>
<p>常量值必须是：</p>
<ul>
<li>字符</li>
<li>字符串</li>
<li>数字</li>
<li>bool</li>
</ul>
<p>常量可以显示的声明类型，当然也支持类型推断。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testConst</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">const</span> name <span class="keyword">string</span> =<span class="string">"eric"</span></span><br><span class="line">    <span class="keyword">const</span> name2 = <span class="string">"eric"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种写法都是对的。</p>
<h3 id="2-常量组"><a href="#2-常量组" class="headerlink" title="2.常量组"></a>2.常量组</h3><p>我们可以定义一系列常量，放到常量组中，这样省事也好看一些。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testConst</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		name =<span class="string">"eric"</span></span><br><span class="line">		age = <span class="number">28</span></span><br><span class="line">		sex = <span class="string">"male"</span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果常量组中元素不指定类型、初始化值，则与上一行非空常量右值相同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testConst</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		x = <span class="number">120</span>		<span class="comment">//120</span></span><br><span class="line">		y			<span class="comment">//120</span></span><br><span class="line">		s = <span class="string">"abc"</span>	<span class="comment">//abc</span></span><br><span class="line">		z			<span class="comment">//abc</span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-枚举"><a href="#3-枚举" class="headerlink" title="3.枚举"></a>3.枚举</h3><p>Go中没有enum的定义，但可以借助iota标识符来实现。</p>
<p>iota 在常量中第1行出现时是0，第2行出现时是1，看起来好像就是const中所在元素的第几行，然后减1的一个值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testEnum</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		x = <span class="literal">iota</span>	<span class="comment">//0</span></span><br><span class="line">		s			<span class="comment">//1</span></span><br><span class="line">		z			<span class="comment">//2</span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testEnum</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		x = <span class="number">100</span>		<span class="comment">//100</span></span><br><span class="line">		s = <span class="literal">iota</span>	<span class="comment">//1</span></span><br><span class="line">		z = <span class="number">33</span>		<span class="comment">//33</span></span><br><span class="line">		m = <span class="literal">iota</span>	<span class="comment">//3</span></span><br><span class="line">		n 			<span class="comment">//4</span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>best practice:在实际应用中，建议用自定义类型实现用途明确的枚举</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义weekend类型</span></span><br><span class="line"><span class="keyword">type</span> weekend <span class="keyword">byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testEnum</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		sun weekend = <span class="literal">iota</span></span><br><span class="line">		mon</span><br><span class="line">		tue</span><br><span class="line">		wed</span><br><span class="line">		thur</span><br><span class="line">		fri</span><br><span class="line">		sat</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-类型"><a href="#三-类型" class="headerlink" title="三. 类型"></a>三. 类型</h2><p>通过一张图看go类型<br><img src="http://static.zybuluo.com/ericliu001/lxo7vbcr0gd271vzgk6o9r22/go%E7%B1%BB%E5%9E%8B.png" alt="go类型.png-327.9kB"></p>
<h3 id="1-类型转换"><a href="#1-类型转换" class="headerlink" title="1.类型转换"></a>1.类型转换</h3><p>GO不支持隐式类型转换，必须显示转换才可以。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">int</span> = <span class="number">8</span></span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">float64</span> = <span class="keyword">float64</span>(m)</span><br></pre></td></tr></table></figure>
<h3 id="2-别名"><a href="#2-别名" class="headerlink" title="2.别名"></a>2.别名</h3><p>通过上面的图我们看到</p>
<ul>
<li>byte是uint8的别名</li>
<li>rune是int32的别名</li>
</ul>
<p>别名不需要类型转换，可以直接赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testAlias</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">//byte alias uint8</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">byte</span> = <span class="number">8</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">uint8</span> = a</span><br><span class="line"></span><br><span class="line">	<span class="comment">//rune alias int32</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">rune</span> = <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> d <span class="keyword">int32</span> = c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-引用类型"><a href="#3-引用类型" class="headerlink" title="3.引用类型"></a>3.引用类型</h3><p>引用类型包括slice、map、channel三种类型，相比数字、数组等类型，引用类型除分配内存外，还会初始化一系列属性，如指针、长度、容量等。</p>
<h3 id="4-自定义类型"><a href="#4-自定义类型" class="headerlink" title="4.自定义类型"></a>4.自定义类型</h3><p>color为自定义类型，但不是byte的别名，color与byte是两种完全不同的类型。<br>除操作符外，自定义类型不会集成基础类型的任何信息(包括方法)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> color <span class="keyword">byte</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Golang 学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>二. Golang中的表达式</title>
    <url>/2020/05/31/golang_expression/</url>
    <content><![CDATA[<h2 id="一-运算符"><a href="#一-运算符" class="headerlink" title="一. 运算符"></a>一. 运算符</h2><p>Go语言的运算符和大多数语言一样，我们只看比较特殊的。</p>
<h3 id="1-自增-自减"><a href="#1-自增-自减" class="headerlink" title="1.自增/自减"></a>1.自增/自减</h3><p>自增/自减 只能作为独立语句，不能用于表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">    <span class="comment">//语法错误</span></span><br><span class="line">	<span class="keyword">if</span> (a++) &gt; <span class="number">1</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时自增/自减，只能是后置操作，不能前置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	<span class="comment">//正确</span></span><br><span class="line">	a++</span><br><span class="line">	<span class="comment">//错误</span></span><br><span class="line">	++a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-指针"><a href="#2-指针" class="headerlink" title="2.指针"></a>2.指针</h3><p>内存地址与指针是两回事，不能混为一谈。内存地址是内存中每个字节单元的唯一编号，而指针是一个实体。‘指针会分配内存空间专门来保存对象的内存地址。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &amp; 取址运算符</span></span><br><span class="line"><span class="comment">// * 间接使用指针指向的内存地址的对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	x:=<span class="number">10</span></span><br><span class="line">	<span class="comment">//p保存x的内存地址</span></span><br><span class="line">	<span class="keyword">var</span> p *<span class="keyword">int</span>=&amp;x</span><br><span class="line">	<span class="comment">//*p实际上就是x</span></span><br><span class="line">	*p+=<span class="number">20</span></span><br><span class="line">	<span class="comment">//30 0xc00002e770</span></span><br><span class="line">	<span class="built_in">println</span>(*p,p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针类型只支持相等运算符，不支持加减乘除等运算。<br>如果两个指针指向相同的空间，或都为nil，则相等，否则不等。</p>
<p>指针没有指向“<strong>成员</strong>”的”-&gt;”运算符，统一使用”.”</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	a:= <span class="keyword">struct</span> &#123;</span><br><span class="line">		x <span class="keyword">int</span></span><br><span class="line">	&#125;&#123;&#125;</span><br><span class="line">	a.x=<span class="number">100</span></span><br><span class="line">	p:=&amp;a</span><br><span class="line">	<span class="comment">//相当于p-&gt;x+=100</span></span><br><span class="line">	p.x+=<span class="number">100</span></span><br><span class="line">	<span class="built_in">println</span>(p.x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-流程控制"><a href="#二-流程控制" class="headerlink" title="二. 流程控制"></a>二. 流程控制</h2><h3 id="1-if…else-if…else…"><a href="#1-if…else-if…else…" class="headerlink" title="1.if…else if…else…"></a>1.if…else if…else…</h3><ul>
<li>对初始化语句支持，但初始化语句中定义的变量，使用范围仅限于该语句块内</li>
<li>条件表达式必须是bool类型，可省略括号</li>
<li>左花括号不能另起一行</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">if</span> x:=<span class="number">3</span>;x&gt;<span class="number">5</span>&#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"a"</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> x&lt;<span class="number">12</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"b"</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"c"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-switch"><a href="#2-switch" class="headerlink" title="2.switch"></a>2.switch</h3><ul>
<li>同if…else，switch也支持表达式赋值</li>
<li>同if…else，switch左花括号也不能另起一行</li>
<li>case a,b 代表 case a || case b</li>
<li>每个case默认break，如果不想break，需执行fallthrough，但不再匹配后续条件表达式</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面代码输出 a|b y</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	x,y,a,b:=<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">switch</span> x &#123;</span><br><span class="line">	<span class="keyword">case</span> a,b:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"a|b"</span>)</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> y:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"y"</span>)</span><br><span class="line">	<span class="keyword">case</span> x:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"x"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"unknown"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>case a,b</code>使用了<code>fallthrough</code>，所以不匹配下一个表达式 <code>case y</code> 了，会直接执行<code>case y</code>的代码。</p>
<p>有时候switch也会被当做if…else来用，此时不用写表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	x:=<span class="number">12</span></span><br><span class="line">	<span class="keyword">switch</span>  &#123;</span><br><span class="line">	<span class="keyword">case</span> x&lt;<span class="number">10</span>:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"x"</span>)</span><br><span class="line">	<span class="keyword">case</span> x&gt;<span class="number">10</span> &amp;&amp; x&lt;<span class="number">15</span>:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"bigger x"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"unknown"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-for"><a href="#3-for" class="headerlink" title="3.for"></a>3.for</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">//正常for语句</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//相当于while(x&lt;5)&#123;x++&#125;</span></span><br><span class="line">	x:=<span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> x&lt;<span class="number">5</span>&#123;</span><br><span class="line">		x++</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//相当于while(true)&#123;break&#125;</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for…range 也可以遍历字符串、数组、数组指针、切片、字典、通道类型，返回索引、键值数据。</p>
<p>需要注意一点，range会复制目标数据，这样的话会影响性能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">	data:&#x3D;[3]int&#123;1,2,3&#125;</span><br><span class="line">	for i,x :&#x3D; range data&#123;</span><br><span class="line">		if i&#x3D;&#x3D;0 &#123;</span><br><span class="line">			data[0] +&#x3D;100</span><br><span class="line">			data[1] +&#x3D;100</span><br><span class="line">			data[2] +&#x3D;100</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 输出</span><br><span class="line">		&#x2F;&#x2F; 1 101</span><br><span class="line">		&#x2F;&#x2F; 2 102</span><br><span class="line">		&#x2F;&#x2F; 3 103</span><br><span class="line">		println(x,data[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看输出，i,x都是从data的复制品取出来的，不管data怎么变化，都不会影响到i,x的值。</p>
<p>为了避免每次都复制影响性能，我们可以使用数组指针或切片类型(仅复制slice、不复制底层array)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	data:=[<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i,x := <span class="keyword">range</span> &amp;data&#123;</span><br><span class="line">		<span class="keyword">if</span> i==<span class="number">0</span> &#123;</span><br><span class="line">			data[<span class="number">0</span>] +=<span class="number">100</span></span><br><span class="line">			data[<span class="number">1</span>] +=<span class="number">100</span></span><br><span class="line">			data[<span class="number">2</span>] +=<span class="number">100</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//输出</span></span><br><span class="line">		<span class="comment">//1 101</span></span><br><span class="line">		<span class="comment">//102 102</span></span><br><span class="line">		<span class="comment">//103 103</span></span><br><span class="line">		<span class="built_in">println</span>(x,data[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上输出，因为x在第1次的时候已经赋值了，所以第1次是1</p>
<p>用于终止或跳过的语句是 <code>break</code>、<code>continue</code>，这个不细说了，比较基础。</p>
]]></content>
      <categories>
        <category>Golang 学习笔记</category>
      </categories>
  </entry>
</search>
